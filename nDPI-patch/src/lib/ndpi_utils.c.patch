--- /home/chrisn/src/ndpi-netfilter/nDPI//src/lib/ndpi_utils.c	2022-06-30 09:34:28.866051274 -0400
+++ /home/chrisn/src/ndpi-netfilter/nDPI-patch//src/lib/ndpi_utils.c	2022-07-01 15:57:47.823000804 -0400
@@ -21,12 +21,12 @@
  *
  */
 
-
+#ifndef __KERNEL__
 #include <stdlib.h>
 #include <errno.h>
 #include <math.h>
 #include <sys/types.h>
-
+#endif
 
 #define NDPI_CURRENT_PROTO NDPI_PROTOCOL_UNKNOWN
 
@@ -38,10 +38,13 @@
 #include "ahocorasick.h"
 #include "libcache.h"
 
+#ifndef __KERNEL__
 #include <time.h>
+#define printf printk
 #ifndef WIN32
 #include <unistd.h>
 #endif
+#endif
 
 #if defined __FreeBSD__ || defined __NetBSD__ || defined __OpenBSD__
 #include <sys/endian.h>
@@ -214,6 +217,17 @@
 }
 
 /* ****************************************** */
+// TODO - some combination of snprintf() and %pI4/%pI6 may work here
+const char * ndpi_inet_ntop(int af, void* src,
+                             char* dst, size_t size)
+{
+  return NULL;
+}
+
+char * ndpi_inet_ntoa(struct in_addr in) 
+{
+  return NULL;
+}
 
 /* Walk the nodes of a tree */
 static void ndpi_tdestroy_recurse(ndpi_node* root, void (*free_action)(void *))
@@ -1153,6 +1167,7 @@
 		  struct ndpi_flow_struct *flow,
 		  ndpi_protocol l7_protocol,
 		  ndpi_serializer *serializer) {
+#if 0
   char buf[64];
 
   if(flow == NULL) return(-1);
@@ -1204,7 +1219,7 @@
     ndpi_serialize_string_uint32(serializer, "query_type",  flow->protos.dns.query_type);
     ndpi_serialize_string_uint32(serializer, "rsp_type",    flow->protos.dns.rsp_type);
 
-    inet_ntop(AF_INET, &flow->protos.dns.rsp_addr, buf, sizeof(buf));
+    ndpi_inet_ntop(AF_INET, &flow->protos.dns.rsp_addr, buf, sizeof(buf));
     ndpi_serialize_string_string(serializer, "rsp_addr",    buf);
     ndpi_serialize_end_of_block(serializer);
     break;
@@ -1386,7 +1401,7 @@
     }
     break;
   } /* switch */
-
+#endif
   return(0);
 }
 
@@ -1408,11 +1423,11 @@
     return(-1);
 
   if(ip_version == 4) {
-    inet_ntop(AF_INET, &src_v4, src_name, sizeof(src_name));
-    inet_ntop(AF_INET, &dst_v4, dst_name, sizeof(dst_name));
+    ndpi_inet_ntop(AF_INET, &src_v4, src_name, sizeof(src_name));
+    ndpi_inet_ntop(AF_INET, &dst_v4, dst_name, sizeof(dst_name));
   } else {
-    inet_ntop(AF_INET6, src_v6, src_name, sizeof(src_name));
-    inet_ntop(AF_INET6, dst_v6, dst_name, sizeof(dst_name));
+    ndpi_inet_ntop(AF_INET6, src_v6, src_name, sizeof(src_name));
+    ndpi_inet_ntop(AF_INET6, dst_v6, dst_name, sizeof(dst_name));
     /* For consistency across platforms replace :0: with :: */
     ndpi_patchIPv6Address(src_name), ndpi_patchIPv6Address(dst_name);
   }
@@ -1533,8 +1548,8 @@
 static void ndpi_compile_rce_regex() {
   const char *pcreErrorStr;
   int pcreErrorOffset;
-
-  for(int i = 0; i < N_RCE_REGEX; i++) {
+  int i;
+  for(i = 0; i < N_RCE_REGEX; i++) {
     comp_rx[i] = (struct pcre_struct*)ndpi_malloc(sizeof(struct pcre_struct));
 
     comp_rx[i]->compiled = pcre_compile(rce_regex[i], 0, &pcreErrorStr,
@@ -1559,7 +1574,7 @@
 #endif
   }
 
-  free((void *)pcreErrorStr);
+  ndpi_free((void *)pcreErrorStr);
 }
 
 static int ndpi_is_rce_injection(char* query) {
@@ -1570,8 +1585,8 @@
 
   int pcreExecRet;
   int subStrVec[30];
-
-  for(int i = 0; i < N_RCE_REGEX; i++) {
+  int i;
+  for(i = 0; i < N_RCE_REGEX; i++) {
     unsigned int length = strlen(query);
 
     pcreExecRet = pcre_exec(comp_rx[i]->compiled,
@@ -1634,7 +1649,7 @@
 /* ********************************** */
 
 ndpi_risk_enum ndpi_validate_url(char *url) {
-  char *orig_str = NULL, *str = NULL, *question_mark = strchr(url, '?');
+  char *orig_str = NULL, *str = NULL, *p = NULL, *question_mark = strchr(url, '?');
   ndpi_risk_enum rc = NDPI_NO_RISK;
 
   if(question_mark) {
@@ -1644,7 +1659,8 @@
 
     if(!str) goto validate_rc;
 
-    str = strtok_r(str, "&", &tmp);
+    p = str;
+    str = strsep(&p, "&");
 
     while(str != NULL) {
       char *value = strchr(str, '=');
@@ -1684,7 +1700,7 @@
 	  break;
       }
 
-      str = strtok_r(NULL, "&", &tmp);
+      str = strsep(&p, "&");
     }
   }
 
@@ -2195,8 +2211,8 @@
 
 int ndpi_is_printable_string(char * const str, size_t len) {
   int retval = 1;
-
-  for (size_t i = 0; i < len; ++i) {
+  size_t i;
+  for (i = 0; i < len; ++i) {
     if (ndpi_isprint(str[i]) == 0) {
       str[i] = '?';
       retval = 0;
@@ -2207,7 +2223,7 @@
 }
 
 /* ******************************************************************** */
-
+#if 0
 float ndpi_entropy(u_int8_t const * const buf, size_t len) {
   float entropy = 0.0f;
   u_int32_t byte_counters[256];
@@ -2226,9 +2242,9 @@
     float const p = (float)byte_counters[i] / len;
     entropy += p * log2f(1 / p);
   }
-
   return entropy;
 }
+#endif
 
 /* ******************************************* */
 
@@ -2282,7 +2298,11 @@
     ac_pattern.length       = strlen(common_alpns[i]);
 
     if(ac_automata_add(ndpi_str->common_alpns_automa.ac_automa, &ac_pattern) != ACERR_SUCCESS)
+#ifndef __KERNEL__
       printf("%s(): unable to add %s\n", __FUNCTION__, common_alpns[i]);
+#else
+      {}
+#endif
   }
 }
 
